<dom-module id="animated-grid">
  <link rel="import" type="css" href="../colors.css">
  <style>
    :host {
      display: block;
      margin: 1em 0;

      position: relative;
      top: 0;
      left: 0;
      @apply(--layout-horizontal);
      @apply(--layout-center-center);
      @apply(--layout-wrap);
    }

    paper-material {
      width: 300px;
      opacity: 1;
      margin: 1em;
      overflow: hidden;
      border-radius: 3px;

      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .hide-result-card {
      width: 0;
      opacity: 0;
      transform: scale(0,0);
    }

    paper-material:hover {
      @apply(--shadow-elevation-8dp);
    }

    .color-box {
      height: 200px;
    }

    .caption-box {
      padding: 1em 1.5em;
      width: 100%;
    }

    google-chart {
      width: 100%;
      height: 100%;
    }
  </style>
  <template>
    <template id="animated-grid-repeat" is="dom-repeat" items="[[data]]" index="index">
      <paper-material class$="[[_compututePaperClass(item.category)]]" elevation="1" on-click="_onClick">
        <div class$="[[_computeColorBoxClass(item.category)]]">
          <!-- TODO Reste a afficher les rÃ©sultats -->
          <p><span>[[analyzeSummary[index].infoValue]]</span>% de info</p>
          <p><span>[[analyzeSummary[index].warningValue]]</span>% de warning</p>
          <p><span>[[analyzeSummary[index].errorValue]]</span>% de error</p>
          <p><span>[[analyzeSummary[index].fileCount]]</span> fichiers</p>
          <p>index = <span>[[index]]</span></p>
        </div>
        <div class="caption-box">[[item.name]]</div>
      </paper-material>
    </template>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'animated-grid',

    behaviors: [
      Polymer.NeonSharedElementAnimatableBehavior
    ],

    properties: {
      analyzeSummary: {
        type: Array,
        value: []
      },
      animationConfig: {
        type: Object,
        value: function() {
          return {
            'exit': [{
              name: 'ripple-animation',
              id: 'ripple',
              fromPage: this
            }, {
              name: 'hero-animation',
              id: 'hero',
              fromPage: this
            }]
          }
        }
      }
    },

    ready: function () {
      var that = this;
      this.$[ 'animated-grid-repeat' ].addEventListener( 'dom-change' , function( e ) {
        console.dir(e);
        e.target.items.forEach(function( result, index ) {
          that._prepareData( result, index );

          console.dir(that.analyzeSummary);
        });
      });
    },

    _onClick: function( e ) {
      var target = e.target;
      while ( target !== this && !target._templateInstance ) {
        target = target.parentNode;
      }

      // configure the page animation
      this.sharedElements = {
        'hero': target.querySelector('.color-box'),
        'fade-in-title': target.querySelector('.caption-box'),
        'ripple': target
      };
      this.animationConfig[ 'exit' ][ 0 ].gesture = {
        x: event.x || event.pageX,
        y: event.y || event.pageY
      };

      this.fire('tile-click', {
        tile: target,
        data: target.data
      });
    },

    _prepareData:function ( results, index ) {
      var that = this;

      // Get the category color for the fullsize card
      results['color'] = app.categories[ results.category ].color.main;

      this.querySelector( '.result-card-' + results.category ).data = results;

      // Set the init counters values
      var summary = {
        infoCount: 0,
        infoValue: 0,
        warningCount: 0,
        warningValue: 0,
        errorCount: 0,
        errorValue: 0,
        fileCount: 0
      };

      // Get the analyze synthese
      results.data.forEach( function( file ) {
        if ( file.errors.length > 0 ) {
          summary.fileCount++;
          file.errors.forEach( function( error ) {
            if ( Array.isArray( error[ 0 ] ) ) {
              error.forEach( function( subError ) {
                summary[ subError.type + 'Count' ]++;
              });
            } else {
              summary[ error.type  + 'Count' ]++;
            }
          });
        }
      });

      var total = summary.infoCount + summary.warningCount + summary.errorCount;
      if ( total ) {
        summary.infoValue = Math.round( ( summary.infoCount / total ) * 10000 ) / 100;
        summary.warningValue = Math.round( ( summary.warningCount / total ) * 10000 ) / 100;
        summary.errorValue = Math.round( ( summary.errorCount / total ) * 10000 ) / 100;
      } else {
        // no error
      }

      this.set( 'analyzeSummary.' + index, summary );
    },

    _computeColorBoxClass: function ( category ) {
      return 'color-box ' + app.categories[ category ].color.main + '-500';
    },

    _compututePaperClass: function ( category ) {
      return 'result-card-' + category;
    }
  });
</script>
